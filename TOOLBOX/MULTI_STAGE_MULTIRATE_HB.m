	function [hvect, H] = MULTI_STAGE_MULTIRATE_HB(wcT, wsT, dc, ds, Nstages)		%	Computes the filters in a multi-stage multirate FIR filter	%	according to Section 15.6 using half-band decimation	%	and interpolation filters.		%	Output:	%	hverct is a verctor hvect(1:Nstages+1,:) of the impulse responses in 	%	the filter stages, 1 to Nstages, and the hvect(Nstages+1,:) is 	%	the kernel filter.		% 	Toolbox for DIGITAL FILTERS USING MATLAB 		% 	Author: 		Hakan Johansson 2010-05-22	% 	Modified by: 	LW 2010-11-16, 2017-02-04	% 	Copyright:		by authors - not released for commercial use	% 	Version:		1	% 	Known bugs:		 	% 	Report bugs to:	Wanhammar@gmail.com		% Determine structural cases 1, 2, 3 and band edges	cases = 0;	edges = 0; Nstage1 = Nstages+1;	for k = 1:Nstages		if wsT <= 0.45*pi			cases(k) = 1; CASE(k) = 'A';			edges(1,k) = wcT;	edges(2,k) = pi-wsT;			wcT = 2*wcT; 	wsT = 2*wsT;		elseif wcT >= 0.55*pi			cases(k) = 2;	CASE(k) = 'B';			edges(1,k) = wsT;	edges(2,k) = pi-wcT;			wcTemp = wcT;	wcT = 2*(pi-wsT);	wsT = 2*(pi-wcTemp);		else			cases(k) = 3;	CASE(k) = 'C';			edges(1,k) = wcT/2;	edges(2,k) = 2*pi/3-wsT/2;			wcT = 3*wcT/2; wsT = 3*wsT/2;		end	end	edges(1, Nstage1) = wcT;	edges(2, Nstage1) = wsT; 	disp(['Cases    ' num2str(cases)])	disp(['Lower band edges/pi   ' num2str(edges(1,:)/pi)])		disp(['Upper band edges/pi   ' num2str(edges(2,:)/pi)])		% Determine sampling ratios	r = 1;	rates = 0;	for k = 1:Nstages		if cases(k) == 3			rates(k) = r;	r = 2*r/3;		else			rates(k) = r;	r = r/2;		end	end	rates(Nstages+1) = r;  	% Determine ripples	ripples = 0;	dcNumb = 0;	dsNumb = 0;	for k = 1:Nstages		s = 0;		for m = 1:k			if cases(m) == 2, s = s+1;end		end		if mod(s,2) == 0, dcNumb = dcNumb+1;			if k == Nstages				casHt = 2;			end		else			dsNumb = dsNumb+1;			if k == Nstages				casHt = 1;			end		end	end	d1 = dc/(2*dcNumb+1);	d2 = ds/(2*dsNumb+1);	if casHt == 1		dcHt = d1;	dsHt = d2;	else		dcHt = d2;	dsHt = d1;	end	dsHt = min(dsHt,ds);	%	disp(['Kernel filter'])	%	disp(['Deviation   '  num2str([dcHt dsHt])])	% Determine filter orders	orders = 0;	for k = 1:Nstages		if cases(k) == 1 			orders(k) =  L_PHASE_LP_HB_FIR_ORDER(edges(2,k), min([d1,d2,ds]));		elseif cases(k) == 2			orders(k) = L_PHASE_LP_HB_FIR_ORDER([pi-edges(2,k) edges(2,k)], min([d1,d2, ds]));		else			[n, Be, D, W] = HERRMANN_LP_FIR_ORDER([edges(1,k) edges(2,k)], [min(d1,d2), ds]);			orders(k) = 2*ceil(n/2); % Make it an even order filter		end	end	[n, Be, D, W] = HERRMANN_LP_FIR_ORDER([edges(1,Nstage1) edges(2,Nstage1)], [dcHt dsHt]);	orders(Nstage1) = 2*floor((n+1)/2);	hvect = zeros(Nstage1,max(orders)+1);	disp(['Filter orders    ' num2str(orders)])	disp(['Sampling ratios    ' num2str(rates)])		% Determine power of z	r = 1;	for k = 1:Nstages		if cases(k) == 3			r(k) = 3/2;		else			r(k) = 2;		end	end	delZ = 0;	delZ(Nstage1) = orders(Nstage1)/2;	for k = Nstages:-1:1		if cases(k) == 3			delZ(k) = r(k)*delZ(k+1)+orders(k)/2;		else			delZ(k) = r(k)*delZ(k+1)+orders(k);		end	end	disp(['Delays'])	for k = 1:Nstages		if cases(k) == 2			disp(['D', num2str(k) ,' = ', num2str(delZ(k))])		end	end	% Group delay	disp(['group delay = ', num2str(delZ(1)), ' T'])	% Compute the average number of multiplications per sample	fmax = 1;	mult = 0;	delays = 0;	for k = 1:Nstages		if cases(k) == 1			mult = mult+rates(k)*(orders(k)+2)/4;			fmax = 2*fmax;		elseif cases(k) == 2			mult = mult+rates(k)*(orders(k)+2)/4;			fmax = 2*fmax;			delays = delays+rates(k)*delZ(k);		else			mult = mult+rates(k)*(orders(k)+2)/3;				fmax = 3*fmax/2;		end	end	% Average number of multiplications per sample	mult = mult+rates(Nstages+1)*(orders(Nstages+1)+2)/2		% Filter design	powZ = 1./rates;	for k = 1:Nstages		if cases(k) == 3			powZ(k) = powZ(k)/2;		end	end	points = 16;	e = exp(1);	[hK, Err] = REMEZ_FIR(orders(Nstage1),[0 edges(1,Nstage1) edges(2,Nstage1) pi],[1 1 0 0],[dcHt dsHt], 'm');	hvect(Nstage1,1:orders(Nstage1)+1) = hK;	% Kernel filter	points = 2;		wT = linspace(0,720,points*720+1);	Htot = freqz(hK,1,wT*pi/180);	for k = Nstages:-1:1		if cases(k) == 1				[hd, Err] = L_PHASE_LP_HB_FIR(orders(k), edges(2,k));			hvect(k,1:orders(k)+1) = hd;			points = 2*points;	wT = linspace(0,720,points*720+1);			Hd = freqz(hd,1,wT*pi/180);			Htot = [Htot Htot(2:length(Htot))];	Htot = Htot.*Hd.*Hd;			elseif cases(k) == 2				[hd, Err] = L_PHASE_LP_HB_FIR(orders(k),pi- edges(2,k));			for m = 1:2:length(hd)				hd(m) = -hd(m);	% Make it a highpas filter			end			hvect(k,1:orders(k)+1) = hd;			points = 2*points;	wT = linspace(0,720,points*720+1);				Hd = freqz(hd,1,wT*pi/180);				Hap = e.^(-j*wT*pi*delZ(k)/180);				Htot = [Htot Htot(2:length(Htot))];	Htot = Hap-Htot.*Hd.*Hd;		else				Htemp = Htot;				Htot = [Htot(points*180+1:points*360) Htot Htot(2:points*180+1)];				Htot2 = [Htemp Htemp(2:points*360+1)];						[hd, Err] = REMEZ_FIR(orders(k), [0 edges(1,k) edges(2,k) pi],[1 1 0 0],[dcHt dsHt], 'm');			hvect(k,1:orders(k)+1) = hd;			points = 3*points/2;	wT = linspace(-180,180,points*720+1);				wT2 = linspace(0,360,points*720+1);				Hd = freqz(hd,1,wT*pi/180);				Hd2 = freqz(hd,1,wT2*pi/180);				Htot = Htot.*Hd.*Hd+Htot2.*Hd2.*Hd2;			end		end	 	H = Htot(1:points*180+1);